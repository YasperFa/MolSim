// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

/**
 * @file
 * @brief Generated from schema.xsd.
 */

#ifndef SCHEMA_H
#define SCHEMA_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema
{
  // anyType and anySimpleType.
  //

  /**
   * @brief C++ type corresponding to the anyType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::type type;

  /**
   * @brief C++ type corresponding to the anySimpleType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;

  /**
   * @brief Alias for the anyType type.
   */
  typedef ::xsd::cxx::tree::type container;


  // 8-bit
  //

  /**
   * @brief C++ type corresponding to the byte XML Schema
   * built-in type.
   */
  typedef signed char byte;

  /**
   * @brief C++ type corresponding to the unsignedByte XML Schema
   * built-in type.
   */
  typedef unsigned char unsigned_byte;


  // 16-bit
  //

  /**
   * @brief C++ type corresponding to the short XML Schema
   * built-in type.
   */
  typedef short short_;

  /**
   * @brief C++ type corresponding to the unsignedShort XML Schema
   * built-in type.
   */
  typedef unsigned short unsigned_short;


  // 32-bit
  //

  /**
   * @brief C++ type corresponding to the int XML Schema
   * built-in type.
   */
  typedef int int_;

  /**
   * @brief C++ type corresponding to the unsignedInt XML Schema
   * built-in type.
   */
  typedef unsigned int unsigned_int;


  // 64-bit
  //

  /**
   * @brief C++ type corresponding to the long XML Schema
   * built-in type.
   */
  typedef long long long_;

  /**
   * @brief C++ type corresponding to the unsignedLong XML Schema
   * built-in type.
   */
  typedef unsigned long long unsigned_long;


  // Supposed to be arbitrary-length integral types.
  //

  /**
   * @brief C++ type corresponding to the integer XML Schema
   * built-in type.
   */
  typedef long long integer;

  /**
   * @brief C++ type corresponding to the nonPositiveInteger XML Schema
   * built-in type.
   */
  typedef long long non_positive_integer;

  /**
   * @brief C++ type corresponding to the nonNegativeInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long non_negative_integer;

  /**
   * @brief C++ type corresponding to the positiveInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long positive_integer;

  /**
   * @brief C++ type corresponding to the negativeInteger XML Schema
   * built-in type.
   */
  typedef long long negative_integer;


  // Boolean.
  //

  /**
   * @brief C++ type corresponding to the boolean XML Schema
   * built-in type.
   */
  typedef bool boolean;


  // Floating-point types.
  //

  /**
   * @brief C++ type corresponding to the float XML Schema
   * built-in type.
   */
  typedef float float_;

  /**
   * @brief C++ type corresponding to the double XML Schema
   * built-in type.
   */
  typedef double double_;

  /**
   * @brief C++ type corresponding to the decimal XML Schema
   * built-in type.
   */
  typedef double decimal;


  // String types.
  //

  /**
   * @brief C++ type corresponding to the string XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::string< char, simple_type > string;

  /**
   * @brief C++ type corresponding to the normalizedString XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;

  /**
   * @brief C++ type corresponding to the token XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;

  /**
   * @brief C++ type corresponding to the Name XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::name< char, token > name;

  /**
   * @brief C++ type corresponding to the NMTOKEN XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;

  /**
   * @brief C++ type corresponding to the NMTOKENS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;

  /**
   * @brief C++ type corresponding to the NCName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;

  /**
   * @brief C++ type corresponding to the language XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::language< char, token > language;


  // ID/IDREF.
  //

  /**
   * @brief C++ type corresponding to the ID XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::id< char, ncname > id;

  /**
   * @brief C++ type corresponding to the IDREF XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;

  /**
   * @brief C++ type corresponding to the IDREFS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;


  // URI.
  //

  /**
   * @brief C++ type corresponding to the anyURI XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;


  // Qualified name.
  //

  /**
   * @brief C++ type corresponding to the QName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;


  // Binary.
  //

  /**
   * @brief Binary buffer type.
   */
  typedef ::xsd::cxx::tree::buffer< char > buffer;

  /**
   * @brief C++ type corresponding to the base64Binary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;

  /**
   * @brief C++ type corresponding to the hexBinary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;


  // Date/time.
  //

  /**
   * @brief Time zone type.
   */
  typedef ::xsd::cxx::tree::time_zone time_zone;

  /**
   * @brief C++ type corresponding to the date XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date< char, simple_type > date;

  /**
   * @brief C++ type corresponding to the dateTime XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;

  /**
   * @brief C++ type corresponding to the duration XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;

  /**
   * @brief C++ type corresponding to the gDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;

  /**
   * @brief C++ type corresponding to the gMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;

  /**
   * @brief C++ type corresponding to the gMonthDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;

  /**
   * @brief C++ type corresponding to the gYear XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;

  /**
   * @brief C++ type corresponding to the gYearMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;

  /**
   * @brief C++ type corresponding to the time XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::time< char, simple_type > time;


  // Entity.
  //

  /**
   * @brief C++ type corresponding to the ENTITY XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;

  /**
   * @brief C++ type corresponding to the ENTITIES XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;



  /**
   * @brief Content order sequence entry.
   */
  typedef ::xsd::cxx::tree::content_order content_order;
  // Flags and properties.
  //

  /**
   * @brief Parsing and serialization flags.
   */
  typedef ::xsd::cxx::tree::flags flags;

  /**
   * @brief Parsing properties.
   */
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //

  /**
   * @brief Error severity.
   */
  typedef ::xsd::cxx::tree::severity severity;

  /**
   * @brief Error condition.
   */
  typedef ::xsd::cxx::tree::error< char > error;

  /**
   * @brief List of %error conditions.
   */
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //

  /**
   * @brief Root of the C++/Tree %exception hierarchy.
   */
  typedef ::xsd::cxx::tree::exception< char > exception;

  /**
   * @brief Exception indicating that the size argument exceeds
   * the capacity argument.
   */
  typedef ::xsd::cxx::tree::bounds< char > bounds;

  /**
   * @brief Exception indicating that a duplicate ID value
   * was encountered in the object model.
   */
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;

  /**
   * @brief Exception indicating a parsing failure.
   */
  typedef ::xsd::cxx::tree::parsing< char > parsing;

  /**
   * @brief Exception indicating that an expected element
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;

  /**
   * @brief Exception indicating that an unexpected element
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;

  /**
   * @brief Exception indicating that an expected attribute
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;

  /**
   * @brief Exception indicating that an unexpected enumerator
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;

  /**
   * @brief Exception indicating that the text content was
   * expected for an element.
   */
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;

  /**
   * @brief Exception indicating that a prefix-namespace
   * mapping was not provided.
   */
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  /**
   * @brief Error handler callback interface.
   */
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  /**
   * @brief DOM interaction.
   */
  namespace dom
  {
    /**
     * @brief Automatic pointer for DOMDocument.
     */
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    /**
     * @brief DOM user data key for back pointers to tree nodes.
     */
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class OutputType;
class CalculatorType;
class ContainerType;
class ParametersType;
class HarmonicForceType;
class ShapeType;
class CuboidType;
class DiscType;
class ParticleType;
class TempType;
class DoubleVectorType;
class ConditionVector;
class DimensionsType;
class ConditionType;
class SubSimulationsType;
class SubSimulationType;
class UpwardForceMarkType;
class SpecialForceType;
class simulation;
class coordinates;

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

/**
 * @brief Class corresponding to the %OutputType schema type.
 *
 * @nosubgrouping
 */
class OutputType: public ::xml_schema::type
{
  public:
  /**
   * @name baseName
   *
   * @brief Accessor and modifier functions for the %baseName
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string baseName_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< baseName_type > baseName_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< baseName_type, char > baseName_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const baseName_optional&
  baseName () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  baseName_optional&
  baseName ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  baseName (const baseName_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  baseName (const baseName_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  baseName (::std::unique_ptr< baseName_type > p);

  //@}

  /**
   * @name writeFrequency
   *
   * @brief Accessor and modifier functions for the %writeFrequency
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ writeFrequency_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< writeFrequency_type > writeFrequency_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< writeFrequency_type, char > writeFrequency_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const writeFrequency_optional&
  writeFrequency () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  writeFrequency_optional&
  writeFrequency ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  writeFrequency (const writeFrequency_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  writeFrequency (const writeFrequency_optional& x);

  /**
   * @brief Return the default value for the element.
   *
   * @return The element's default value.
   */
  static writeFrequency_type
  writeFrequency_default_value ();

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  OutputType ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  OutputType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  OutputType (const OutputType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual OutputType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  OutputType&
  operator= (const OutputType& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~OutputType ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  baseName_optional baseName_;
  writeFrequency_optional writeFrequency_;

  //@endcond
};

/**
 * @brief Class corresponding to the %CalculatorType schema type.
 *
 * @nosubgrouping
 */
class CalculatorType: public ::xml_schema::type
{
  public:
  /**
   * @name calculatorForce
   *
   * @brief Accessor and modifier functions for the %calculatorForce
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string calculatorForce_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< calculatorForce_type > calculatorForce_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< calculatorForce_type, char > calculatorForce_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const calculatorForce_optional&
  calculatorForce () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  calculatorForce_optional&
  calculatorForce ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  calculatorForce (const calculatorForce_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  calculatorForce (const calculatorForce_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  calculatorForce (::std::unique_ptr< calculatorForce_type > p);

  //@}

  /**
   * @name repulsiveOnly
   *
   * @brief Accessor and modifier functions for the %repulsiveOnly
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::boolean repulsiveOnly_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< repulsiveOnly_type > repulsiveOnly_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< repulsiveOnly_type, char > repulsiveOnly_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const repulsiveOnly_optional&
  repulsiveOnly () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  repulsiveOnly_optional&
  repulsiveOnly ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  repulsiveOnly (const repulsiveOnly_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  repulsiveOnly (const repulsiveOnly_optional& x);

  //@}

  /**
   * @name nonNeighboursOnly
   *
   * @brief Accessor and modifier functions for the %nonNeighboursOnly
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::boolean nonNeighboursOnly_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< nonNeighboursOnly_type > nonNeighboursOnly_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< nonNeighboursOnly_type, char > nonNeighboursOnly_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const nonNeighboursOnly_optional&
  nonNeighboursOnly () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  nonNeighboursOnly_optional&
  nonNeighboursOnly ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  nonNeighboursOnly (const nonNeighboursOnly_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  nonNeighboursOnly (const nonNeighboursOnly_optional& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  CalculatorType ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  CalculatorType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  CalculatorType (const CalculatorType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual CalculatorType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  CalculatorType&
  operator= (const CalculatorType& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~CalculatorType ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  calculatorForce_optional calculatorForce_;
  repulsiveOnly_optional repulsiveOnly_;
  nonNeighboursOnly_optional nonNeighboursOnly_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ContainerType schema type.
 *
 * @nosubgrouping
 */
class ContainerType: public ::xml_schema::type
{
  public:
  /**
   * @name containerType
   *
   * @brief Accessor and modifier functions for the %containerType
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string containerType_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< containerType_type, char > containerType_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const containerType_type&
  containerType () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  containerType_type&
  containerType ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  containerType (const containerType_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  containerType (::std::unique_ptr< containerType_type > p);

  //@}

  /**
   * @name cutoffRadius
   *
   * @brief Accessor and modifier functions for the %cutoffRadius
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ cutoffRadius_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< cutoffRadius_type > cutoffRadius_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< cutoffRadius_type, char, ::xsd::cxx::tree::schema_type::double_ > cutoffRadius_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const cutoffRadius_optional&
  cutoffRadius () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  cutoffRadius_optional&
  cutoffRadius ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  cutoffRadius (const cutoffRadius_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  cutoffRadius (const cutoffRadius_optional& x);

  //@}

  /**
   * @name domainSize
   *
   * @brief Accessor and modifier functions for the %domainSize
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::DoubleVectorType domainSize_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< domainSize_type > domainSize_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< domainSize_type, char > domainSize_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const domainSize_optional&
  domainSize () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  domainSize_optional&
  domainSize ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  domainSize (const domainSize_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  domainSize (const domainSize_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  domainSize (::std::unique_ptr< domainSize_type > p);

  //@}

  /**
   * @name boundaryType
   *
   * @brief Accessor and modifier functions for the %boundaryType
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ConditionVector boundaryType_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< boundaryType_type > boundaryType_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< boundaryType_type, char > boundaryType_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const boundaryType_optional&
  boundaryType () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  boundaryType_optional&
  boundaryType ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  boundaryType (const boundaryType_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  boundaryType (const boundaryType_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  boundaryType (::std::unique_ptr< boundaryType_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ContainerType (const containerType_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ContainerType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ContainerType (const ContainerType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ContainerType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ContainerType&
  operator= (const ContainerType& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ContainerType ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< containerType_type > containerType_;
  cutoffRadius_optional cutoffRadius_;
  domainSize_optional domainSize_;
  boundaryType_optional boundaryType_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ParametersType schema type.
 *
 * @nosubgrouping
 */
class ParametersType: public ::xml_schema::type
{
  public:
  /**
   * @name tEnd
   *
   * @brief Accessor and modifier functions for the %tEnd
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ tEnd_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< tEnd_type > tEnd_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< tEnd_type, char, ::xsd::cxx::tree::schema_type::double_ > tEnd_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const tEnd_optional&
  tEnd () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  tEnd_optional&
  tEnd ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  tEnd (const tEnd_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  tEnd (const tEnd_optional& x);

  //@}

  /**
   * @name deltaT
   *
   * @brief Accessor and modifier functions for the %deltaT
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ deltaT_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< deltaT_type > deltaT_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< deltaT_type, char, ::xsd::cxx::tree::schema_type::double_ > deltaT_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const deltaT_optional&
  deltaT () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  deltaT_optional&
  deltaT ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  deltaT (const deltaT_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  deltaT (const deltaT_optional& x);

  //@}

  /**
   * @name gravity
   *
   * @brief Accessor and modifier functions for the %gravity
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ gravity_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< gravity_type > gravity_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< gravity_type, char, ::xsd::cxx::tree::schema_type::double_ > gravity_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const gravity_optional&
  gravity () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  gravity_optional&
  gravity ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  gravity (const gravity_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  gravity (const gravity_optional& x);

  //@}

  /**
   * @name gravityAxis
   *
   * @brief Accessor and modifier functions for the %gravityAxis
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string gravityAxis_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< gravityAxis_type > gravityAxis_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< gravityAxis_type, char > gravityAxis_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const gravityAxis_optional&
  gravityAxis () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  gravityAxis_optional&
  gravityAxis ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  gravityAxis (const gravityAxis_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  gravityAxis (const gravityAxis_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  gravityAxis (::std::unique_ptr< gravityAxis_type > p);

  //@}

  /**
   * @name parallelVersion2
   *
   * @brief Accessor and modifier functions for the %parallelVersion2
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::boolean parallelVersion2_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< parallelVersion2_type > parallelVersion2_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< parallelVersion2_type, char > parallelVersion2_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const parallelVersion2_optional&
  parallelVersion2 () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  parallelVersion2_optional&
  parallelVersion2 ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  parallelVersion2 (const parallelVersion2_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  parallelVersion2 (const parallelVersion2_optional& x);

  //@}

  /**
   * @name assignNeighbours
   *
   * @brief Accessor and modifier functions for the %assignNeighbours
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::boolean assignNeighbours_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< assignNeighbours_type > assignNeighbours_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< assignNeighbours_type, char > assignNeighbours_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const assignNeighbours_optional&
  assignNeighbours () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  assignNeighbours_optional&
  assignNeighbours ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  assignNeighbours (const assignNeighbours_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  assignNeighbours (const assignNeighbours_optional& x);

  /**
   * @brief Return the default value for the element.
   *
   * @return The element's default value.
   */
  static assignNeighbours_type
  assignNeighbours_default_value ();

  //@}

  /**
   * @name harmonicForce
   *
   * @brief Accessor and modifier functions for the %harmonicForce
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::HarmonicForceType harmonicForce_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< harmonicForce_type > harmonicForce_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< harmonicForce_type, char > harmonicForce_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const harmonicForce_optional&
  harmonicForce () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  harmonicForce_optional&
  harmonicForce ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  harmonicForce (const harmonicForce_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  harmonicForce (const harmonicForce_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  harmonicForce (::std::unique_ptr< harmonicForce_type > p);

  //@}

  /**
   * @name specialForce
   *
   * @brief Accessor and modifier functions for the %specialForce
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::SpecialForceType specialForce_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< specialForce_type > specialForce_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< specialForce_type, char > specialForce_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const specialForce_optional&
  specialForce () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  specialForce_optional&
  specialForce ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  specialForce (const specialForce_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  specialForce (const specialForce_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  specialForce (::std::unique_ptr< specialForce_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ParametersType ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ParametersType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ParametersType (const ParametersType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ParametersType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ParametersType&
  operator= (const ParametersType& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ParametersType ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  tEnd_optional tEnd_;
  deltaT_optional deltaT_;
  gravity_optional gravity_;
  gravityAxis_optional gravityAxis_;
  parallelVersion2_optional parallelVersion2_;
  assignNeighbours_optional assignNeighbours_;
  harmonicForce_optional harmonicForce_;
  specialForce_optional specialForce_;

  //@endcond
};

/**
 * @brief Class corresponding to the %HarmonicForceType schema type.
 *
 * @nosubgrouping
 */
class HarmonicForceType: public ::xml_schema::type
{
  public:
  /**
   * @name harmonicOn
   *
   * @brief Accessor and modifier functions for the %harmonicOn
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::boolean harmonicOn_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< harmonicOn_type, char > harmonicOn_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const harmonicOn_type&
  harmonicOn () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  harmonicOn_type&
  harmonicOn ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  harmonicOn (const harmonicOn_type& x);

  /**
   * @brief Return the default value for the element.
   *
   * @return The element's default value.
   */
  static harmonicOn_type
  harmonicOn_default_value ();

  //@}

  /**
   * @name stiffnessConstant
   *
   * @brief Accessor and modifier functions for the %stiffnessConstant
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ stiffnessConstant_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< stiffnessConstant_type > stiffnessConstant_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< stiffnessConstant_type, char, ::xsd::cxx::tree::schema_type::double_ > stiffnessConstant_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const stiffnessConstant_optional&
  stiffnessConstant () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  stiffnessConstant_optional&
  stiffnessConstant ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  stiffnessConstant (const stiffnessConstant_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  stiffnessConstant (const stiffnessConstant_optional& x);

  /**
   * @brief Return the default value for the element.
   *
   * @return The element's default value.
   */
  static stiffnessConstant_type
  stiffnessConstant_default_value ();

  //@}

  /**
   * @name avgBondLength
   *
   * @brief Accessor and modifier functions for the %avgBondLength
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ avgBondLength_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< avgBondLength_type > avgBondLength_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< avgBondLength_type, char, ::xsd::cxx::tree::schema_type::double_ > avgBondLength_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const avgBondLength_optional&
  avgBondLength () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  avgBondLength_optional&
  avgBondLength ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  avgBondLength (const avgBondLength_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  avgBondLength (const avgBondLength_optional& x);

  /**
   * @brief Return the default value for the element.
   *
   * @return The element's default value.
   */
  static avgBondLength_type
  avgBondLength_default_value ();

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  HarmonicForceType (const harmonicOn_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  HarmonicForceType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  HarmonicForceType (const HarmonicForceType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual HarmonicForceType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  HarmonicForceType&
  operator= (const HarmonicForceType& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~HarmonicForceType ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< harmonicOn_type > harmonicOn_;
  stiffnessConstant_optional stiffnessConstant_;
  avgBondLength_optional avgBondLength_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ShapeType schema type.
 *
 * @nosubgrouping
 */
class ShapeType: public ::xml_schema::type
{
  public:
  /**
   * @name cuboid
   *
   * @brief Accessor and modifier functions for the %cuboid
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::CuboidType cuboid_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< cuboid_type > cuboid_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef cuboid_sequence::iterator cuboid_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef cuboid_sequence::const_iterator cuboid_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< cuboid_type, char > cuboid_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const cuboid_sequence&
  cuboid () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  cuboid_sequence&
  cuboid ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  cuboid (const cuboid_sequence& s);

  //@}

  /**
   * @name disc
   *
   * @brief Accessor and modifier functions for the %disc
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::DiscType disc_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< disc_type > disc_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef disc_sequence::iterator disc_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef disc_sequence::const_iterator disc_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< disc_type, char > disc_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const disc_sequence&
  disc () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  disc_sequence&
  disc ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  disc (const disc_sequence& s);

  //@}

  /**
   * @name particle
   *
   * @brief Accessor and modifier functions for the %particle
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ParticleType particle_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< particle_type > particle_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef particle_sequence::iterator particle_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef particle_sequence::const_iterator particle_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< particle_type, char > particle_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const particle_sequence&
  particle () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  particle_sequence&
  particle ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  particle (const particle_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ShapeType ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ShapeType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ShapeType (const ShapeType& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ShapeType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ShapeType&
  operator= (const ShapeType& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ShapeType ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  cuboid_sequence cuboid_;
  disc_sequence disc_;
  particle_sequence particle_;

  //@endcond
};

/**
 * @brief Class corresponding to the %CuboidType schema type.
 *
 * @nosubgrouping
 */
class CuboidType: public ::xml_schema::type
{
  public:
  /**
   * @name position
   *
   * @brief Accessor and modifier functions for the %position
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::DoubleVectorType position_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< position_type, char > position_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const position_type&
  position () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  position_type&
  position ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  position (const position_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  position (::std::unique_ptr< position_type > p);

  //@}

  /**
   * @name dimensions
   *
   * @brief Accessor and modifier functions for the %dimensions
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::DimensionsType dimensions_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< dimensions_type, char > dimensions_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const dimensions_type&
  dimensions () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  dimensions_type&
  dimensions ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  dimensions (const dimensions_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  dimensions (::std::unique_ptr< dimensions_type > p);

  //@}

  /**
   * @name initialVelocity
   *
   * @brief Accessor and modifier functions for the %initialVelocity
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::DoubleVectorType initialVelocity_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< initialVelocity_type, char > initialVelocity_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const initialVelocity_type&
  initialVelocity () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  initialVelocity_type&
  initialVelocity ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  initialVelocity (const initialVelocity_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  initialVelocity (::std::unique_ptr< initialVelocity_type > p);

  //@}

  /**
   * @name distance
   *
   * @brief Accessor and modifier functions for the %distance
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ distance_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< distance_type, char, ::xsd::cxx::tree::schema_type::double_ > distance_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const distance_type&
  distance () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  distance_type&
  distance ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  distance (const distance_type& x);

  //@}

  /**
   * @name meanVelocity
   *
   * @brief Accessor and modifier functions for the %meanVelocity
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ meanVelocity_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< meanVelocity_type, char, ::xsd::cxx::tree::schema_type::double_ > meanVelocity_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const meanVelocity_type&
  meanVelocity () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  meanVelocity_type&
  meanVelocity ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  meanVelocity (const meanVelocity_type& x);

  //@}

  /**
   * @name mass
   *
   * @brief Accessor and modifier functions for the %mass
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ mass_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< mass_type, char, ::xsd::cxx::tree::schema_type::double_ > mass_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const mass_type&
  mass () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  mass_type&
  mass ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  mass (const mass_type& x);

  //@}

  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ type_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const type_optional&
  type () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  type_optional&
  type ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  type (const type_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  type (const type_optional& x);

  //@}

  /**
   * @name epsilon
   *
   * @brief Accessor and modifier functions for the %epsilon
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ epsilon_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< epsilon_type > epsilon_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< epsilon_type, char, ::xsd::cxx::tree::schema_type::double_ > epsilon_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const epsilon_optional&
  epsilon () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  epsilon_optional&
  epsilon ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  epsilon (const epsilon_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  epsilon (const epsilon_optional& x);

  //@}

  /**
   * @name sigma
   *
   * @brief Accessor and modifier functions for the %sigma
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ sigma_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< sigma_type > sigma_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< sigma_type, char, ::xsd::cxx::tree::schema_type::double_ > sigma_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const sigma_optional&
  sigma () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  sigma_optional&
  sigma ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  sigma (const sigma_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  sigma (const sigma_optional& x);

  //@}

  /**
   * @name isFixed
   *
   * @brief Accessor and modifier functions for the %isFixed
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::boolean isFixed_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< isFixed_type > isFixed_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< isFixed_type, char > isFixed_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const isFixed_optional&
  isFixed () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  isFixed_optional&
  isFixed ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  isFixed (const isFixed_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  isFixed (const isFixed_optional& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  CuboidType (const position_type&,
              const dimensions_type&,
              const initialVelocity_type&,
              const distance_type&,
              const meanVelocity_type&,
              const mass_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  CuboidType (::std::unique_ptr< position_type >,
              ::std::unique_ptr< dimensions_type >,
              ::std::unique_ptr< initialVelocity_type >,
              const distance_type&,
              const meanVelocity_type&,
              const mass_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  CuboidType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  CuboidType (const CuboidType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual CuboidType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  CuboidType&
  operator= (const CuboidType& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~CuboidType ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< position_type > position_;
  ::xsd::cxx::tree::one< dimensions_type > dimensions_;
  ::xsd::cxx::tree::one< initialVelocity_type > initialVelocity_;
  ::xsd::cxx::tree::one< distance_type > distance_;
  ::xsd::cxx::tree::one< meanVelocity_type > meanVelocity_;
  ::xsd::cxx::tree::one< mass_type > mass_;
  type_optional type_;
  epsilon_optional epsilon_;
  sigma_optional sigma_;
  isFixed_optional isFixed_;

  //@endcond
};

/**
 * @brief Class corresponding to the %DiscType schema type.
 *
 * @nosubgrouping
 */
class DiscType: public ::xml_schema::type
{
  public:
  /**
   * @name center
   *
   * @brief Accessor and modifier functions for the %center
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::DoubleVectorType center_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< center_type, char > center_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const center_type&
  center () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  center_type&
  center ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  center (const center_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  center (::std::unique_ptr< center_type > p);

  //@}

  /**
   * @name radius
   *
   * @brief Accessor and modifier functions for the %radius
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ radius_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< radius_type, char > radius_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const radius_type&
  radius () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  radius_type&
  radius ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  radius (const radius_type& x);

  //@}

  /**
   * @name initialVelocity
   *
   * @brief Accessor and modifier functions for the %initialVelocity
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::DoubleVectorType initialVelocity_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< initialVelocity_type, char > initialVelocity_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const initialVelocity_type&
  initialVelocity () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  initialVelocity_type&
  initialVelocity ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  initialVelocity (const initialVelocity_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  initialVelocity (::std::unique_ptr< initialVelocity_type > p);

  //@}

  /**
   * @name distance
   *
   * @brief Accessor and modifier functions for the %distance
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ distance_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< distance_type, char, ::xsd::cxx::tree::schema_type::double_ > distance_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const distance_type&
  distance () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  distance_type&
  distance ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  distance (const distance_type& x);

  //@}

  /**
   * @name mass
   *
   * @brief Accessor and modifier functions for the %mass
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ mass_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< mass_type, char, ::xsd::cxx::tree::schema_type::double_ > mass_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const mass_type&
  mass () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  mass_type&
  mass ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  mass (const mass_type& x);

  //@}

  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ type_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const type_optional&
  type () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  type_optional&
  type ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  type (const type_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  type (const type_optional& x);

  //@}

  /**
   * @name epsilon
   *
   * @brief Accessor and modifier functions for the %epsilon
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ epsilon_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< epsilon_type > epsilon_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< epsilon_type, char, ::xsd::cxx::tree::schema_type::double_ > epsilon_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const epsilon_optional&
  epsilon () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  epsilon_optional&
  epsilon ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  epsilon (const epsilon_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  epsilon (const epsilon_optional& x);

  //@}

  /**
   * @name sigma
   *
   * @brief Accessor and modifier functions for the %sigma
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ sigma_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< sigma_type > sigma_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< sigma_type, char, ::xsd::cxx::tree::schema_type::double_ > sigma_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const sigma_optional&
  sigma () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  sigma_optional&
  sigma ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  sigma (const sigma_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  sigma (const sigma_optional& x);

  //@}

  /**
   * @name isFixed
   *
   * @brief Accessor and modifier functions for the %isFixed
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::boolean isFixed_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< isFixed_type > isFixed_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< isFixed_type, char > isFixed_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const isFixed_optional&
  isFixed () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  isFixed_optional&
  isFixed ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  isFixed (const isFixed_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  isFixed (const isFixed_optional& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  DiscType (const center_type&,
            const radius_type&,
            const initialVelocity_type&,
            const distance_type&,
            const mass_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  DiscType (::std::unique_ptr< center_type >,
            const radius_type&,
            ::std::unique_ptr< initialVelocity_type >,
            const distance_type&,
            const mass_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  DiscType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  DiscType (const DiscType& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual DiscType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  DiscType&
  operator= (const DiscType& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~DiscType ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< center_type > center_;
  ::xsd::cxx::tree::one< radius_type > radius_;
  ::xsd::cxx::tree::one< initialVelocity_type > initialVelocity_;
  ::xsd::cxx::tree::one< distance_type > distance_;
  ::xsd::cxx::tree::one< mass_type > mass_;
  type_optional type_;
  epsilon_optional epsilon_;
  sigma_optional sigma_;
  isFixed_optional isFixed_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ParticleType schema type.
 *
 * @nosubgrouping
 */
class ParticleType: public ::xml_schema::type
{
  public:
  /**
   * @name position
   *
   * @brief Accessor and modifier functions for the %position
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::DoubleVectorType position_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< position_type, char > position_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const position_type&
  position () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  position_type&
  position ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  position (const position_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  position (::std::unique_ptr< position_type > p);

  //@}

  /**
   * @name velocity
   *
   * @brief Accessor and modifier functions for the %velocity
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::DoubleVectorType velocity_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< velocity_type, char > velocity_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const velocity_type&
  velocity () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  velocity_type&
  velocity ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  velocity (const velocity_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  velocity (::std::unique_ptr< velocity_type > p);

  //@}

  /**
   * @name mass
   *
   * @brief Accessor and modifier functions for the %mass
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ mass_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< mass_type, char, ::xsd::cxx::tree::schema_type::double_ > mass_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const mass_type&
  mass () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  mass_type&
  mass ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  mass (const mass_type& x);

  //@}

  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ type_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const type_optional&
  type () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  type_optional&
  type ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  type (const type_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  type (const type_optional& x);

  //@}

  /**
   * @name epsilon
   *
   * @brief Accessor and modifier functions for the %epsilon
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ epsilon_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< epsilon_type > epsilon_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< epsilon_type, char, ::xsd::cxx::tree::schema_type::double_ > epsilon_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const epsilon_optional&
  epsilon () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  epsilon_optional&
  epsilon ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  epsilon (const epsilon_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  epsilon (const epsilon_optional& x);

  //@}

  /**
   * @name sigma
   *
   * @brief Accessor and modifier functions for the %sigma
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ sigma_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< sigma_type > sigma_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< sigma_type, char, ::xsd::cxx::tree::schema_type::double_ > sigma_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const sigma_optional&
  sigma () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  sigma_optional&
  sigma ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  sigma (const sigma_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  sigma (const sigma_optional& x);

  //@}

  /**
   * @name isFixed
   *
   * @brief Accessor and modifier functions for the %isFixed
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::boolean isFixed_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< isFixed_type > isFixed_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< isFixed_type, char > isFixed_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const isFixed_optional&
  isFixed () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  isFixed_optional&
  isFixed ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  isFixed (const isFixed_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  isFixed (const isFixed_optional& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ParticleType (const position_type&,
                const velocity_type&,
                const mass_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  ParticleType (::std::unique_ptr< position_type >,
                ::std::unique_ptr< velocity_type >,
                const mass_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ParticleType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ParticleType (const ParticleType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ParticleType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ParticleType&
  operator= (const ParticleType& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ParticleType ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< position_type > position_;
  ::xsd::cxx::tree::one< velocity_type > velocity_;
  ::xsd::cxx::tree::one< mass_type > mass_;
  type_optional type_;
  epsilon_optional epsilon_;
  sigma_optional sigma_;
  isFixed_optional isFixed_;

  //@endcond
};

/**
 * @brief Class corresponding to the %TempType schema type.
 *
 * @nosubgrouping
 */
class TempType: public ::xml_schema::type
{
  public:
  /**
   * @name ThermoType
   *
   * @brief Accessor and modifier functions for the %ThermoType
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string ThermoType_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< ThermoType_type, char > ThermoType_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const ThermoType_type&
  ThermoType () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  ThermoType_type&
  ThermoType ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  ThermoType (const ThermoType_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  ThermoType (::std::unique_ptr< ThermoType_type > p);

  //@}

  /**
   * @name initialTemperature
   *
   * @brief Accessor and modifier functions for the %initialTemperature
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ initialTemperature_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< initialTemperature_type, char, ::xsd::cxx::tree::schema_type::double_ > initialTemperature_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const initialTemperature_type&
  initialTemperature () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  initialTemperature_type&
  initialTemperature ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  initialTemperature (const initialTemperature_type& x);

  //@}

  /**
   * @name timeSteps
   *
   * @brief Accessor and modifier functions for the %timeSteps
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ timeSteps_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< timeSteps_type, char > timeSteps_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const timeSteps_type&
  timeSteps () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  timeSteps_type&
  timeSteps ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  timeSteps (const timeSteps_type& x);

  //@}

  /**
   * @name targetTemperature
   *
   * @brief Accessor and modifier functions for the %targetTemperature
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ targetTemperature_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< targetTemperature_type > targetTemperature_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< targetTemperature_type, char, ::xsd::cxx::tree::schema_type::double_ > targetTemperature_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const targetTemperature_optional&
  targetTemperature () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  targetTemperature_optional&
  targetTemperature ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  targetTemperature (const targetTemperature_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  targetTemperature (const targetTemperature_optional& x);

  //@}

  /**
   * @name maxDeltaTemperature
   *
   * @brief Accessor and modifier functions for the %maxDeltaTemperature
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ maxDeltaTemperature_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< maxDeltaTemperature_type > maxDeltaTemperature_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< maxDeltaTemperature_type, char, ::xsd::cxx::tree::schema_type::double_ > maxDeltaTemperature_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const maxDeltaTemperature_optional&
  maxDeltaTemperature () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  maxDeltaTemperature_optional&
  maxDeltaTemperature ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  maxDeltaTemperature (const maxDeltaTemperature_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  maxDeltaTemperature (const maxDeltaTemperature_optional& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  TempType (const ThermoType_type&,
            const initialTemperature_type&,
            const timeSteps_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  TempType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  TempType (const TempType& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual TempType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  TempType&
  operator= (const TempType& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~TempType ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< ThermoType_type > ThermoType_;
  ::xsd::cxx::tree::one< initialTemperature_type > initialTemperature_;
  ::xsd::cxx::tree::one< timeSteps_type > timeSteps_;
  targetTemperature_optional targetTemperature_;
  maxDeltaTemperature_optional maxDeltaTemperature_;

  //@endcond
};

/**
 * @brief Class corresponding to the %DoubleVectorType schema type.
 *
 * @nosubgrouping
 */
class DoubleVectorType: public ::xml_schema::type
{
  public:
  /**
   * @name x
   *
   * @brief Accessor and modifier functions for the %x
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ x_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::double_ > x_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const x_type&
  x () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  x_type&
  x ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  x (const x_type& x);

  //@}

  /**
   * @name y
   *
   * @brief Accessor and modifier functions for the %y
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ y_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< y_type, char, ::xsd::cxx::tree::schema_type::double_ > y_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const y_type&
  y () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  y_type&
  y ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  y (const y_type& x);

  //@}

  /**
   * @name z
   *
   * @brief Accessor and modifier functions for the %z
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ z_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< z_type, char, ::xsd::cxx::tree::schema_type::double_ > z_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const z_type&
  z () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  z_type&
  z ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  z (const z_type& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  DoubleVectorType (const x_type&,
                    const y_type&,
                    const z_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  DoubleVectorType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  DoubleVectorType (const DoubleVectorType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual DoubleVectorType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  DoubleVectorType&
  operator= (const DoubleVectorType& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~DoubleVectorType ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< x_type > x_;
  ::xsd::cxx::tree::one< y_type > y_;
  ::xsd::cxx::tree::one< z_type > z_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ConditionVector schema type.
 *
 * @nosubgrouping
 */
class ConditionVector: public ::xml_schema::type
{
  public:
  /**
   * @name left
   *
   * @brief Accessor and modifier functions for the %left
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ConditionType left_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< left_type, char > left_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const left_type&
  left () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  left_type&
  left ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  left (const left_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  left (::std::unique_ptr< left_type > p);

  //@}

  /**
   * @name right
   *
   * @brief Accessor and modifier functions for the %right
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ConditionType right_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< right_type, char > right_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const right_type&
  right () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  right_type&
  right ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  right (const right_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  right (::std::unique_ptr< right_type > p);

  //@}

  /**
   * @name top
   *
   * @brief Accessor and modifier functions for the %top
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ConditionType top_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< top_type, char > top_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const top_type&
  top () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  top_type&
  top ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  top (const top_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  top (::std::unique_ptr< top_type > p);

  //@}

  /**
   * @name bottom
   *
   * @brief Accessor and modifier functions for the %bottom
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ConditionType bottom_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< bottom_type, char > bottom_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const bottom_type&
  bottom () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  bottom_type&
  bottom ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  bottom (const bottom_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  bottom (::std::unique_ptr< bottom_type > p);

  //@}

  /**
   * @name front
   *
   * @brief Accessor and modifier functions for the %front
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ConditionType front_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< front_type, char > front_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const front_type&
  front () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  front_type&
  front ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  front (const front_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  front (::std::unique_ptr< front_type > p);

  //@}

  /**
   * @name back
   *
   * @brief Accessor and modifier functions for the %back
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ConditionType back_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< back_type, char > back_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const back_type&
  back () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  back_type&
  back ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  back (const back_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  back (::std::unique_ptr< back_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ConditionVector (const left_type&,
                   const right_type&,
                   const top_type&,
                   const bottom_type&,
                   const front_type&,
                   const back_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ConditionVector (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ConditionVector (const ConditionVector& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ConditionVector*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ConditionVector&
  operator= (const ConditionVector& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ConditionVector ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< left_type > left_;
  ::xsd::cxx::tree::one< right_type > right_;
  ::xsd::cxx::tree::one< top_type > top_;
  ::xsd::cxx::tree::one< bottom_type > bottom_;
  ::xsd::cxx::tree::one< front_type > front_;
  ::xsd::cxx::tree::one< back_type > back_;

  //@endcond
};

/**
 * @brief Class corresponding to the %DimensionsType schema type.
 *
 * @nosubgrouping
 */
class DimensionsType: public ::xml_schema::type
{
  public:
  /**
   * @name x
   *
   * @brief Accessor and modifier functions for the %x
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ x_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< x_type, char > x_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const x_type&
  x () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  x_type&
  x ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  x (const x_type& x);

  //@}

  /**
   * @name y
   *
   * @brief Accessor and modifier functions for the %y
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ y_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< y_type, char > y_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const y_type&
  y () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  y_type&
  y ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  y (const y_type& x);

  //@}

  /**
   * @name z
   *
   * @brief Accessor and modifier functions for the %z
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ z_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< z_type, char > z_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const z_type&
  z () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  z_type&
  z ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  z (const z_type& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  DimensionsType (const x_type&,
                  const y_type&,
                  const z_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  DimensionsType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  DimensionsType (const DimensionsType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual DimensionsType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  DimensionsType&
  operator= (const DimensionsType& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~DimensionsType ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< x_type > x_;
  ::xsd::cxx::tree::one< y_type > y_;
  ::xsd::cxx::tree::one< z_type > z_;

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %ConditionType
 * schema type.
 */
class ConditionType: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    outflow,
    reflecting,
    periodic
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  ConditionType (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  ConditionType (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  ConditionType (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  ConditionType (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ConditionType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ConditionType (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ConditionType (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ConditionType (const ConditionType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

#ifdef XSD_CXX11
  ConditionType&
  operator= (const ConditionType&) = default;
#endif

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ConditionType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  ConditionType&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_ConditionType_convert ();
  }

  //@cond

  protected:
  value
  _xsd_ConditionType_convert () const;

  public:
  static const char* const _xsd_ConditionType_literals_[3];
  static const value _xsd_ConditionType_indexes_[3];

  //@endcond
};

/**
 * @brief Class corresponding to the %SubSimulationsType schema type.
 *
 * @nosubgrouping
 */
class SubSimulationsType: public ::xml_schema::type
{
  public:
  /**
   * @name subSimulation
   *
   * @brief Accessor and modifier functions for the %subSimulation
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::SubSimulationType subSimulation_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< subSimulation_type > subSimulation_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef subSimulation_sequence::iterator subSimulation_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef subSimulation_sequence::const_iterator subSimulation_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< subSimulation_type, char > subSimulation_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const subSimulation_sequence&
  subSimulation () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  subSimulation_sequence&
  subSimulation ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  subSimulation (const subSimulation_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  SubSimulationsType ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  SubSimulationsType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  SubSimulationsType (const SubSimulationsType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual SubSimulationsType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  SubSimulationsType&
  operator= (const SubSimulationsType& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~SubSimulationsType ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  subSimulation_sequence subSimulation_;

  //@endcond
};

/**
 * @brief Class corresponding to the %SubSimulationType schema type.
 *
 * @nosubgrouping
 */
class SubSimulationType: public ::xml_schema::type
{
  public:
  /**
   * @name name
   *
   * @brief Accessor and modifier functions for the %name
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string name_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const name_type&
  name () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  name_type&
  name ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  name (const name_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  name (::std::unique_ptr< name_type > p);

  //@}

  /**
   * @name inputFile
   *
   * @brief Accessor and modifier functions for the %inputFile
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string inputFile_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< inputFile_type, char > inputFile_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const inputFile_type&
  inputFile () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  inputFile_type&
  inputFile ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  inputFile (const inputFile_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  inputFile (::std::unique_ptr< inputFile_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  SubSimulationType (const name_type&,
                     const inputFile_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  SubSimulationType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  SubSimulationType (const SubSimulationType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual SubSimulationType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  SubSimulationType&
  operator= (const SubSimulationType& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~SubSimulationType ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< name_type > name_;
  ::xsd::cxx::tree::one< inputFile_type > inputFile_;

  //@endcond
};

/**
 * @brief Class corresponding to the %UpwardForceMarkType schema type.
 *
 * @nosubgrouping
 */
class UpwardForceMarkType: public ::xml_schema::type
{
  public:
  /**
   * @name coordinates
   *
   * @brief Accessor and modifier functions for the %coordinates
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::coordinates coordinates_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< coordinates_type > coordinates_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef coordinates_sequence::iterator coordinates_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef coordinates_sequence::const_iterator coordinates_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< coordinates_type, char > coordinates_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const coordinates_sequence&
  coordinates () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  coordinates_sequence&
  coordinates ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  coordinates (const coordinates_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  UpwardForceMarkType ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  UpwardForceMarkType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  UpwardForceMarkType (const UpwardForceMarkType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual UpwardForceMarkType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  UpwardForceMarkType&
  operator= (const UpwardForceMarkType& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~UpwardForceMarkType ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  coordinates_sequence coordinates_;

  //@endcond
};

/**
 * @brief Class corresponding to the %SpecialForceType schema type.
 *
 * @nosubgrouping
 */
class SpecialForceType: public ::xml_schema::type
{
  public:
  /**
   * @name upwardForce
   *
   * @brief Accessor and modifier functions for the %upwardForce
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ upwardForce_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< upwardForce_type, char, ::xsd::cxx::tree::schema_type::double_ > upwardForce_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const upwardForce_type&
  upwardForce () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  upwardForce_type&
  upwardForce ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  upwardForce (const upwardForce_type& x);

  //@}

  /**
   * @name forceAxis
   *
   * @brief Accessor and modifier functions for the %forceAxis
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string forceAxis_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< forceAxis_type, char > forceAxis_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const forceAxis_type&
  forceAxis () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  forceAxis_type&
  forceAxis ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  forceAxis (const forceAxis_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  forceAxis (::std::unique_ptr< forceAxis_type > p);

  //@}

  /**
   * @name activeTimeSteps
   *
   * @brief Accessor and modifier functions for the %activeTimeSteps
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ activeTimeSteps_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< activeTimeSteps_type, char > activeTimeSteps_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const activeTimeSteps_type&
  activeTimeSteps () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  activeTimeSteps_type&
  activeTimeSteps ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  activeTimeSteps (const activeTimeSteps_type& x);

  //@}

  /**
   * @name markedParticles
   *
   * @brief Accessor and modifier functions for the %markedParticles
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::UpwardForceMarkType markedParticles_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< markedParticles_type, char > markedParticles_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const markedParticles_type&
  markedParticles () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  markedParticles_type&
  markedParticles ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  markedParticles (const markedParticles_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  markedParticles (::std::unique_ptr< markedParticles_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  SpecialForceType (const upwardForce_type&,
                    const forceAxis_type&,
                    const activeTimeSteps_type&,
                    const markedParticles_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  SpecialForceType (const upwardForce_type&,
                    const forceAxis_type&,
                    const activeTimeSteps_type&,
                    ::std::unique_ptr< markedParticles_type >);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  SpecialForceType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  SpecialForceType (const SpecialForceType& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual SpecialForceType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  SpecialForceType&
  operator= (const SpecialForceType& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~SpecialForceType ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< upwardForce_type > upwardForce_;
  ::xsd::cxx::tree::one< forceAxis_type > forceAxis_;
  ::xsd::cxx::tree::one< activeTimeSteps_type > activeTimeSteps_;
  ::xsd::cxx::tree::one< markedParticles_type > markedParticles_;

  //@endcond
};

/**
 * @brief Class corresponding to the %simulation schema type.
 *
 * @nosubgrouping
 */
class simulation: public ::xml_schema::type
{
  public:
  /**
   * @name output
   *
   * @brief Accessor and modifier functions for the %output
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::OutputType output_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< output_type, char > output_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const output_type&
  output () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  output_type&
  output ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  output (const output_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  output (::std::unique_ptr< output_type > p);

  //@}

  /**
   * @name calculator
   *
   * @brief Accessor and modifier functions for the %calculator
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::CalculatorType calculator_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< calculator_type, char > calculator_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const calculator_type&
  calculator () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  calculator_type&
  calculator ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  calculator (const calculator_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  calculator (::std::unique_ptr< calculator_type > p);

  //@}

  /**
   * @name container
   *
   * @brief Accessor and modifier functions for the %container
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ContainerType container_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< container_type, char > container_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const container_type&
  container () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  container_type&
  container ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  container (const container_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  container (::std::unique_ptr< container_type > p);

  //@}

  /**
   * @name parameters
   *
   * @brief Accessor and modifier functions for the %parameters
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ParametersType parameters_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< parameters_type, char > parameters_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const parameters_type&
  parameters () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  parameters_type&
  parameters ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  parameters (const parameters_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  parameters (::std::unique_ptr< parameters_type > p);

  //@}

  /**
   * @name shapes
   *
   * @brief Accessor and modifier functions for the %shapes
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ShapeType shapes_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< shapes_type, char > shapes_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const shapes_type&
  shapes () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  shapes_type&
  shapes ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  shapes (const shapes_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  shapes (::std::unique_ptr< shapes_type > p);

  //@}

  /**
   * @name temperature
   *
   * @brief Accessor and modifier functions for the %temperature
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::TempType temperature_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< temperature_type > temperature_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< temperature_type, char > temperature_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const temperature_optional&
  temperature () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  temperature_optional&
  temperature ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  temperature (const temperature_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  temperature (const temperature_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  temperature (::std::unique_ptr< temperature_type > p);

  //@}

  /**
   * @name subSimulations
   *
   * @brief Accessor and modifier functions for the %subSimulations
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::SubSimulationsType subSimulations_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< subSimulations_type > subSimulations_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< subSimulations_type, char > subSimulations_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const subSimulations_optional&
  subSimulations () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  subSimulations_optional&
  subSimulations ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  subSimulations (const subSimulations_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  subSimulations (const subSimulations_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  subSimulations (::std::unique_ptr< subSimulations_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  simulation (const output_type&,
              const calculator_type&,
              const container_type&,
              const parameters_type&,
              const shapes_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  simulation (::std::unique_ptr< output_type >,
              ::std::unique_ptr< calculator_type >,
              ::std::unique_ptr< container_type >,
              ::std::unique_ptr< parameters_type >,
              ::std::unique_ptr< shapes_type >);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  simulation (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  simulation (const simulation& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual simulation*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  simulation&
  operator= (const simulation& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~simulation ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< output_type > output_;
  ::xsd::cxx::tree::one< calculator_type > calculator_;
  ::xsd::cxx::tree::one< container_type > container_;
  ::xsd::cxx::tree::one< parameters_type > parameters_;
  ::xsd::cxx::tree::one< shapes_type > shapes_;
  temperature_optional temperature_;
  subSimulations_optional subSimulations_;

  //@endcond
};

/**
 * @brief Class corresponding to the %coordinates schema type.
 *
 * @nosubgrouping
 */
class coordinates: public ::xml_schema::type
{
  public:
  /**
   * @name x
   *
   * @brief Accessor and modifier functions for the %x
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ x_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::double_ > x_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const x_type&
  x () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  x_type&
  x ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  x (const x_type& x);

  //@}

  /**
   * @name y
   *
   * @brief Accessor and modifier functions for the %y
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ y_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< y_type, char, ::xsd::cxx::tree::schema_type::double_ > y_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const y_type&
  y () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  y_type&
  y ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  y (const y_type& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  coordinates (const x_type&,
               const y_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  coordinates (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  coordinates (const coordinates& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual coordinates*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  coordinates&
  operator= (const coordinates& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~coordinates ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< x_type > x_;
  ::xsd::cxx::tree::one< y_type > y_;

  //@endcond
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

/**
 * @name Parsing functions for the %simulation document root.
 */
//@{

/**
 * @brief Parse a URI or a local file.
 *
 * @param uri A URI or a local file name.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::simulation >
simulation_ (const ::std::string& uri,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a URI or a local file with an error handler.
 *
 * @param uri A URI or a local file name.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::simulation >
simulation_ (const ::std::string& uri,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a URI or a local file with a Xerces-C++ DOM error
 * handler.
 *
 * @param uri A URI or a local file name.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::simulation >
simulation_ (const ::std::string& uri,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream.
 *
 * @param is A standrad input stream.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with an error handler.
 *
 * @param is A standrad input stream.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a Xerces-C++ DOM error
 * handler.
 *
 * @param is A standrad input stream.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::simulation >
simulation_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a resource id.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& id,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a resource id and an
 * error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& id,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a resource id and a
 * Xerces-C++ DOM error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::simulation >
simulation_ (::std::istream& is,
             const ::std::string& id,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ input source.
 *
 * @param is A Xerces-C++ input source.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::simulation >
simulation_ (::xercesc::InputSource& is,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ input source with an error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::simulation >
simulation_ (::xercesc::InputSource& is,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
 * error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::simulation >
simulation_ (::xercesc::InputSource& is,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 */
::std::unique_ptr< ::simulation >
simulation_ (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A pointer to the Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function is normally used together with the keep_dom and
 * own_dom parsing flags to assign ownership of the DOM document
 * to the object model.
 */
::std::unique_ptr< ::simulation >
simulation_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

//@}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // SCHEMA_H
