/*
 * Particle.cpp
 *
 *  Created on: 23.02.2010
 *      Author: eckhardw
 */
#include "spdlog/spdlog.h"
#include "Particle.h"
#include <iostream>
#include "utils/ArrayUtils.h"
#include <exception>

Particle::Particle(int type_arg) {
    type = type_arg;
    f = {0., 0., 0.};
    old_f = {0., 0., 0.};
    old_x = {NAN, NAN, NAN}; //for initial periodic boundary handling
    id = ParticleIdInitializer::getNewId();
    epsilon = 5;
    sigma = 1;
    SPDLOG_DEBUG("Empty Particle with id {} generated!", id);
    partner = {0, 0, 0};
    isFixed = false;
}

Particle::Particle(const Particle &other) {
    x = other.x;
    v = other.v;
    f = other.f;
    old_f = other.old_f;
    old_x = other.old_x;
    m = other.m;
    type = other.type;
    id = other.id;
    sigma = other.sigma;
    epsilon = other.epsilon;
    SPDLOG_DEBUG("Particle with id {} generated by copy!", id);
    partner = other.partner;
    isFixed = other.isFixed;
}

// Todo: maybe use initializater list instead of copy?
Particle::Particle(std::array<double, 3> x_arg, std::array<double, 3> v_arg,
                   double m_arg, int type_arg, double epsilon_arg, double sigma_arg, bool isFixed) : x(x_arg), v(v_arg),
    m(m_arg), type(type_arg), epsilon(epsilon_arg), sigma(sigma_arg), isFixed(isFixed) {
    f = {0., 0., 0.};
    old_f = {0., 0., 0.};
    old_x = {NAN, NAN, NAN};
    id = ParticleIdInitializer::getNewId();
    SPDLOG_DEBUG("Particle with id {} generated by value!", id);
    partner = {0, 0, 0};
}

Particle::~Particle() { SPDLOG_DEBUG("Particle destructed!"); }

const std::array<double, 3> &Particle::getX() const { return x; }

const std::array<double, 3> &Particle::getOldX() const { return old_x; }

const std::array<double, 3> &Particle::getV() const { return v; }

const std::array<double, 3> &Particle::getF() const { return f; }

const std::array<double, 3> &Particle::getOldF() const { return old_f; }

int Particle::getID() const { return id; }

double Particle::getM() const { return m; }

int Particle::getType() const { return type; }

double Particle::getEpsilon() { return epsilon; }

double Particle::getSigma() { return sigma; }

void Particle::setPartner(int i, int id) {
    switch (i) {
        case 0: partner[0] = id;
            return;
        case 1: partner[0] = id;
            return;
        case 2: partner[1] = id;
            return;
        case 3: partner[1] = id;
            return;
        case 4: partner[2] = id;
            return;
        default: partner[2] = id;
            return;
    }
}

int Particle::getPartner(int i) {
    switch (i) {
        case 0: return partner[0];
        case 1: return partner[0];
        case 2: return partner[1];
        case 3: return partner[1];
        case 4: return partner[2];
        default: return partner[2];
    }
}


void Particle::setF(const std::array<double, 3> &newF) {
    forceMutex.lock();
    f[0] = newF[0];
    f[1] = newF[1];
    f[2] = newF[2];
    forceMutex.unlock();
}

void Particle::setOldF(const std::array<double, 3> &newOldF) {
    old_f[0] = newOldF[0];
    old_f[1] = newOldF[1];
    old_f[2] = newOldF[2];
}

void Particle::setX(const std::array<double, 3> &X) {
    x[0] = X[0];
    x[1] = X[1];
    x[2] = X[2];
}

void Particle::setOldX(const std::array<double, 3> &newOldX) {
    old_x[0] = newOldX[0];
    old_x[1] = newOldX[1];
    old_x[2] = newOldX[2];
}

void Particle::setV(const std::array<double, 3> &V) {
    v[0] = V[0];
    v[1] = V[1];
    v[2] = V[2];
}


std::string Particle::toString() const {
    std::stringstream stream;
    stream << "Particle: X:" << x << " v: " << v << " f: " << f
            << " old_f: " << old_f << " type: " << type << " id: " << id << " partners:" << partner;
    return stream.str();
}

Particle &Particle::operator=(const Particle &other) {
    x = other.x;
    v = other.v;
    f = other.f;
    old_f = other.old_f;
    old_x = other.old_x;
    m = other.m;
    type = other.type;
    id = other.id;
    sigma = other.sigma;
    epsilon = other.epsilon;
    partner = other.partner;
    isFixed = other.isFixed;
    return *this;
}

bool Particle::operator==(Particle &other) {
    return (x == other.x) and (v == other.v) and (f == other.f) and
           (type == other.type) and (m == other.m) and (old_f == other.old_f);
}

bool Particle::operator==(const Particle &other) {
    return (x == other.x) and (v == other.v) and (f == other.f) and
           (type == other.type) and (m == other.m) and (old_f == other.old_f);
}

std::ostream &operator<<(std::ostream &stream, Particle &p) {
    stream << p.toString();
    return stream;
}

bool Particle::getFixed() const {
    return isFixed;
}

void Particle::fixParticle() {
    isFixed = true;
}

// neighbour functions
const std::vector<int> &Particle::getDiagonalNeighbourIds() const {
    return diagonalNeighbourIds;
}

const std::vector<int> &Particle::getDirectNeighbourIds() const {
    return diagonalNeighbourIds;
}

void Particle::addDiagonalNeighbour(int neighbourID) {
    diagonalNeighbourIds.push_back(neighbourID);
}

void Particle::addDirectNeighbour(int neighbourID) {
    diagonalNeighbourIds.push_back(neighbourID);
}

bool Particle::isDiagonalNeighbour(const Particle &other) const {
    return std::find(diagonalNeighbourIds.begin(), diagonalNeighbourIds.end(), other.getID()) != diagonalNeighbourIds.
           end();
}

bool Particle::isDirectNeighbour(const Particle &other) const {
    return std::find(directNeighbourIds.begin(), directNeighbourIds.end(), other.getID()) != directNeighbourIds.end();
}

bool Particle::isNeighbour(const Particle &other) const {
    return isDiagonalNeighbour(other) || isDirectNeighbour(other);
}

void Particle::markForUpwardForce() {
    markedForUpwardForce = true;
}

bool Particle::upwardForceMarked() const {
    return markedForUpwardForce;
}
